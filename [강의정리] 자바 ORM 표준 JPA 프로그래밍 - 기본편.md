
## [1] JPA 소개
---
### ✅ SQL 중심적인 개발의 문제점
>  **관계형 데이터베이스의 모델링** 과 **객체지향 모델링** 기법 간의 차이로 인해 객체답게 모델링 할수록 매핑 작업만 늘어나게 되고, 결국 데이터 모델링에 맞춰 프로그램을 설계할 수 밖에 없어진다.

#
### ✅ 객체를 Collection에 저장하듯이 DB에 저장할 수 없을까?
> Java ORM 표준인 JPA를 이용하면 가능하다. JPA는 애플리케이션과 DB 사이에서 동작하며 이 둘을 매핑해주는데, 이를 통해 패러다임의 불일치를 해결하고, SQL 중심적인 개발에서 객체 중심 개발로 나아갈 수 있다.

#
### ✅ JPA의 성능 최적화 기능
 1. 1차 캐시와 동일성(identity) 보장
> - 같은 트랜잭션 안에서는 같은 엔티티를 반환 : 약간의 조회성능 향상
> - DB Isolation Level이 Read Commit 이어도 애플리케이션에서 Repeatable Read 보장
 2. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
> - 트랜잭션을 커밋할 때까지 INSERT SQL을 모음
> - JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
> - UPDATE, DELETE로 인한 Row lock 시간 최소화
> - 트랜잭션 커밋 시 UPDATE, DELETE SQL 실행하고 바로 커밋
 3. 지연 로딩(Lazy Loading)
> - 지연 로딩 : 객체가 실제 사용될 때 로딩
>> ex. SELECT * FROM MEMBER; SELECT * FROM TEAM;
> - 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회
>> ex. SELECT M.*, T.* FROM MEMBER JOIN TEAM ...

#
## [2] JPA 시작하기
---
### ✅ JPA 설정 중 중요한 부분
- JPA 설정은 /META-INF/persistence.xml 에 위치해야 함
- javax.persitence로 시작하는 건 JPA 표준속성, hibernate로 시작하는건 하이버네이트 전용 속성임
- **hibernate.dialect 속성** 지정
    > 💡 _데이터베이스 방언이란?_  
    > SQL 표준을 지키지 않는 DB만의 고유한 기능을 방언이라고 하며, JPA는 특정 데이터베이스에 종속되지 않기 때문에 이러한 데이터베이스 방언을 지원해야 한다. 실제 Hibernate는 40가지 이상의 데이터베이스 방언을 지원한다.
    > - MySQLDialect : MySQL SQL 생성
    > - OracleDialect : Oracle SQL 생성
    > - H2Dialect : H2 SQL 생성  
- java 11 오류 해결 : https://www.inflearn.com/questions/13985

### ✅ JPA 구동 방식
- Java의 Persistence 클래스가 META-INF/persistence.xml에 저장된 설정 정보를 조회한다.
- 설정에 따라 EntityManagerFactory를 생성한다.
    > EntityManagerFactory는 하나만 생성해서 어플리케이션 전체에 공유함
- EntityManagerFactory는 EntityManager 들을 생성한다.
    > EntityManager는 쓰레드 간에 공유가 되지 않으며, JPA의 모든 데이터 변경은 트랜잭션 안에서 실행됨

### ✅ JPA 어노테이션
- @Entity : JPA가 관리할 객체
- @Id : 데이터베이스 PK와 매핑 

### ✅ JPQL
- 객체를 대상으로 검색하는 객체 지향 쿼리
- 뒤에서 아주 자세히 다룰 예정이기 때문에 이런걸 사용한다는 정도만 알고 갈 것 

#
## [3] 영속성 관리 - 내부 동작 방식 
---
### ✅ 영속성 컨텍스트(PersistenceContext)
- 영속성 컨텍스트는 논리적인 개념으로 눈에 보이지 않는다.
- JPA는 EntityManager를 통해 PersistenceContext에 접근한다.
- J2SE 에서는 1:1로 매핑되고, J2EE/스프링 같은 컨테이너 환경에선 N:1로 매핑된다.
> **엔티티 생명주기**
> - 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 
> - 영속 : 영속성 컨텍스트에 관리되는 상태 // em.persist(member)
> - 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태 // em.detach(member)
> - 삭제 : 삭제된 상태 // em.remove(member)

> **영속성 컨텍스트의 이점**
> - 1차 캐시 : 조회 성능 개선
>   - 1차 캐시에서 조회해오는 것과 같지만, 성능 향상이 효과는 미미함.
>   - 트랜잭션 단위로 생성되었다가 사라지기 때문에 효과가 크지 않음.
> - 1차 캐시 : 동일성 보장
>   - 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 어플리케이션 차원에서 제공함. 
> - 트랜잭션을 지원하는 쓰기 지연
>   - 커밋 이전에는 DB에 insert 하지 않다가, commit 시점에 한 번에 쓰기 작업을 수행
> - 변경 감지(Dirty Checking)
>   - setter 연산을 통해 객체의 정보를 변경한 후에 em.update 와 같은 별도의 작업 없이도, 영속성 컨텍스트에서 관리되고 있는 객체의 변경 내용을 감지하여 반영함
> - 지연 로딩(Lazy Loading)

### ✅ 플러시(flush)
> 영속성 컨텍스트의 변경내용을 데이터베이스에 반영함.
> 
> 플러시에는 세 가지 방법이 있음.
> - em.flush() : 직접 호출
> - 트랜잭션 커밋 : 플러시 자동 호출
> - JPQL 쿼리 실행 : 플러시 자동 호출
>   - JPQL 쿼리 실행 시점에 플러시가 호출되지 않는다면, 영속성 컨텍스트에 저장한 이후 커밋 이전에 JPQL을 사용해 해당 객체를 select 하고자 하면 원하는 객체를 찾을 수 없을 것이다. 

> 플러시의 특성
> - 영속성 컨텍스트를 비우지 않음
> - 영속성 컨텍스트의 변경내용을 DB에 동기화 함
> - 데이터 영속성 관리를 위해서는 결국 트랜잭션이라는 작업 단위가 가장 중요하다. 트랜잭션이 커밋되지 않으면 변경내용이 큰 의미가 없기 때문에, 커밋 직전에만 동기화 하면 된다. 따라서 영속성 컨텍스트와 트랜잭션 주기를 맞춰서(영속성 컨텍스트를 생성하며 트랜잭션을 시작하고 커밋하며 컨텍스트를 날리는?) 설계하고 개발해야 한다. 또한, 이런 이유로 JPA를 사용하면서 데이터 동기화를 너무 크게 생각하지 않아도 된다.

### ✅ 준영속 상태(detached)
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리되고, 영속성 컨텍스트가 제공하는 기능(Dirty check 등)을 사용하지 못하게 됨.
> 준영속 상태로 만드는 법
> - em.detach(entity)
> - em.clear()
> - em.close()

#
## [4] 엔티티 매핑 
---
JPA에서 제일 중요하게 봐야하는 2가지
1. 메커니즘적 측면 : 영속성 컨텍스트, JPA 내부 동작 방식
2. 설계적 측면 : 객체와 관계형 DB를 어떻게 매핑해서 사용하는지 
=> 이번 장에서는 설계적 측면에서 어떻게 엔티티를 매핑하는지 살펴보겠음

### ✅ 엔티티 매핑
- 객체와 테이블 매핑 : @Entity, @Table
- 필드와 컬럼 매핑 : @Column
- 기본 키 매핑 : @Id
- 연관관계 매핑 : @ManyToOne, @JoinColumn
    - ex) Member <-> Team 간의 연관관계를 어떤식으로 매핑해야 하는지

### ✅ 객체와 테이블 매핑
- @Entity가 붙은 클래스는 JPA가 관리하며, 엔티티라고 부른다.
- JPA를 사용해서 테이블과 매핑할 클래스는 반드시 @Entity를 사용한다.
- 주의사항
    - 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
    - final 클래스, enum, interface, inner 클래스 사용 안 됨
    - DB 저장할 필드에 final 사용하면 안 됨
- @Entity
    - option: name
    - default는 클래스명과 같고, 보통은 사용하지 않지만 다른 패키지에 같은 이름을 가진 클래스가 존재하는 경우 구분을 위해 사용할 수 있음
- @Table
    - option : name
    - @Table option으로 지정해준 이름을 가진 테이블과 엔티티를 매핑해줌

### ✅ 데이터베이스 스키마 자동 생성
- 어플리케이션 로딩 시점에 자동으로 DDL을 생성함
    - 운영에선 절대 create, create-drop, update 사용하면 안 됨
    - 개발환경에서 가볍게 사용할 수 있음
    - 테이블 중심 -> 객체 중심
- <property name = "hibernate.hbm2ddl.auto" value="create" />
    - value 에 다양한 값을 설정해서 여러 속성으로 활용 가능함
    - 딱히 쓸 일 없을 것 같아서 정리는 안하니 필요하면 강의안 참고

### ✅ 필드와 컬럼 매핑
- @Column
    - 다양한 옵션들
    > - insertable, updatable : 기본은 true, 등록만 하고 이후 변경 금지하고 싶은 경우엔 updatable을 false로 설정
    > - nullable : not null 제약 조건을 사용하고 싶을 때
    > - unique : unique 제약 조건 사용하고 싶을 때 -> 잘 안 쓰임(제약조건 이름이 임의로 생성되기 때문에) -> Entity 단위의 @Table annotation에 uniqueConstraints 설정해주는게 좋음
    > - columnDefinition
    > - length : 길이 제약 조건
- @Enumerated 
    - 사용 시 주의사항
    > - 기본 값인 ORDINAL을 사용하면 안 됨 : integer 타입으로 설정되는데, ENUM에 새로운 값이 추가 되는 경우 순서가 바뀌기 때문에 큰 문제가 생길 수 있음
    > -  따라서, 반드시 STRING으로 사용 : varchar 타입으로 설정되고, ENUM 값이 그대로 들어감.
- @Temporal
    > - Java 8 이후 거의 사용할 일이 없어짐
    > - LocalDate : Hibernate가 자동으로 DB date type으로 생성해줌
    > - LocalDateTime : Hibernate가 자동으로 DB timestamp type으로 생성해줌
- @Lob
    > - 데이터베이스 BLOB, CLOB 타입과 매핑됨. 따로 지정할 수 있는 속성은 없음
    > - CLOB : 매핑하는 필드 타입이 문자인 경우
    > - BLOB : 나머지
- @Transient
    > - 매핑하고 싶지 않을 때 사용
    > - DB에서 관리하지 않고 memory 에서만 사용하고 싶을 때

### ✅ 기본 키 매핑
- @GeneratedValue
    > strategy 옵션으로 아래의 값들을 사용할 수 있음
    > - IDENTITY : 기본 키 생성을 데이터베이스에 위임 ex) MySQL auto_increment
    > - SEQUENCE : Sequence Object에서 값을 가져와 PK 설정 ex) Oracle sequence
    >   - SEQUENCE 사용하는 경우 필드 타입이 숫자형 이어야 하는데, Long을 쓰는걸 추천함. Integer의 경우 10억을 넘어가면 사용하기가 힘든데, Long을 씀으로써 발생하는 성능저하가 운영환경에서 Data type을 변경하는 작업의 어려움에 비하면 trade-off 에서 이점이 있기 때문임.
    >   - Entity 단위에서 @SequenceGenerator 를 이용해 테이블마다 별도의 sequence 객체를 생성할 수도 있음
    >   - allocationSize 를 늘려(default = 50), DB I/O time을 줄일 수 있음. 매번 nextval 를 하지 않고 한번 접근할 때 50개를 생성하고 memory에 올려두고 사용하다가 모두 소진되면 다시 DB에 접근해서 50개를 가져오는 방식. 여러 대의 서버에서도 동시성 이슈 없이 사용 가능함.
    >   - Q... 근데 이거 동시성 문제는 없을 지라도 Key가 중구난방으로 생성되는 문제는 생길 수 있는거 아닌감??
    > - TABLE : 키 생성 전용 테이블을 만들어서 DB sequence를 흉내내는 전략
    >   - 장점 : 모든 데이터베이스에 적용 가능함
    >   - 단점 : 성능(운영에서 사용하기엔 부담스러움)
- 권장하는 식별자 전략(PK 설정 전략)
    > - Long + 대체키 + 키 생성전략 사용
    > - 결론
    >   1. auto_increment나 sequence 중 사용하거나
    >   2. 랜덤 값을 조합한 회사 내의 채번 Rule에 따른 값 사용
    > - 절대 비즈니스 유효값을 Key로 사용하지 말자 ex) 주민등록번호를 회원 테이블의 Key에 쓰지 말자

### ✅ 실전 예제 1 - 요구사항 분석과 기본 매핑
- SpringBootApplication으로 실행하는 경우 스프링프레임워크가 java의 카멜케이스 표기법을 따른 변수를 DB의 언더스코어 표기법으로 자동으로 바꿔줌(기본 설정)
- 처음 매핑한 코드를 보면 뭔가 이상함을 알 수 있다
    - Order를 찾아와서, 해당 주문을 요청한 고객을 찾고 싶다면, Order table을 key로 조회하고, 결과로 얻은 Order 객체에서 member ID를 받아와 다시 Member 테이블에서 고객을 찾아와야 한다.
    - 데이터 중심 설계의 문제점
        - 객체지향적으로 설계되지 않고, 객체 설계를 테이블 설계에 맞춘 방식
        - 테이블의 외래키를 객체에 그대로 가져옴
        - 객체 그래프 탐색이 불가함
        - 참조가 없기 때문에 UML도 잘못됨
    - 다음 시간부터는 이러한 데이터 중심 설계의 문제점을 해결하기 위한 연관관계 매핑을 살펴보도록 하겠음

#
## [5] 연관관계 매핑 기초
---

### 학습목표
    - 객체와 테이블 연관관계의 차이를 이해
    - 객체의 참조와 테이블의 FK를 매핑
    - 용어의 이해
        - 방향 : 단방향, 양방향
        - 다중성 : N:1, 1:N, 1:1, N:M
        - 연관관계의 주인(Owner) : 객체 양방향 연관관게는 관리 주인이 필요함

### ✅ 단방향 연관관계
- 단순히 FK 저장해두고, 해당 FK 이용해 다른 테이블을 조회하는 게 아니라 보다 객체지향적인 관점에서 어플리케이션을 설계할 수 없을까?
    - 어플리케이션 설계에서 가장 어려운 부분임. 객체가 지향하는 패러다임과 관계형 DB가 지향하는 패러다임이 다르기 때문에 둘 간의 차이에서 오는 어려움이 있음
    - 한번 잘 배워두면 도움이 될 주제임
- 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.
    - 기존 데이터베이스 모델 기반의 설계로는 협력관계를 반영하기 어려움
- @ManyToOne
>   - N:1 관계에서 N 쪽에 붙여줌
>   - @JoinColumn(name="")
>       - name 속성을 이용해 참조하는 테이블의 어떤 값을 이용해 매핑해줄지를 결정함(FK-PK 관계와 유사)
>   - 객체를 바로 꺼내쓸 수 있게 됨

### ✅ 양방향 연관관계와 연관관계의 주인1 - 기본
- JPA 기본 강의에서 가장 중요한 내용임
- 기존 단방향 연관관계와 테이블 모델링에는 아무런 변화가 없음
    - why? 테이블의 모델링에서는 FK 하나로 양방향 연관관계가 성립하기 때문임
- 문제는 객체 모델링임
    - 이전 예제에서 Member는 Team을 필드로 가졌고, Member에서는 Team의 정보를 불러올 수 있었음.
    - 그러나, Team은 Member를 가지지 못했기 때문에, Team에서는 Member를 참조하는 것이 불가능 했음.
    - 따라서, Team에 List<Members>를 넣어줘야지만 양방향 참조가 가능해짐.
- 결론 : 객체 모델링과 데이터(테이블) 모델링의 가장 큰 차이는 객체의 경우 양방향 참조를 위해서는 각각의 객체에 연관관계를 포함시켜줘야 하지만, 테이블의 경우 FK 만을 이용해도 양방향 연관관계 표현 및 참조가 가능함.
- @OneToMany(mappedBy = "")
>   - mappedBy 옵션에 반대편 Side의 객체에서 참조되는 변수명을 값으로 지정해주면 양방향 연관관계 매핑이 이뤄짐
>   - 이를 통해 반대 방향으로도 객체 그래프 탐색이 가능해짐
- 연관관계의 주인과 mappedBy
    - mappedBy : JPA 멘탈붕괴 난이도
    > - 앞서 살펴본 바와 같이 객체와 테이블이 관계를 맺는 방식에는 차이가 존재한다. 테이블은 1개의 연관관계 FK만을 갖고도 양방향 참조가 가능하지만, 객체의 경우 단방향 연관관계 두개를 각각 지정해줘야 양방향 참조가 가능해진다.
    > - 다시 말해, 객체의 양방향 관계는 사실 양방향 관계가 아닌 서로 다른 단방향 관계 2개를 의미한다. 반면, 테이블은 FK 하나로 두 테이블 간의 연관관계를 관리한다.
    > - 그럼 2개의 단방향 관계 중 어느걸로 테이블의 FK를 관리해야 할까? 연관관계의 주인(Owner)를 지정해줘야 한다.
    - 연관관계의 주인(Owner)
    > - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정해준다.
    > - 연관관계의 주인만이 외래키를 관리한다(등록 및 수정 가능)
    > - 연관관계에서 주인이 아닌 쪽은 읽기만 가능하다.
    > - 주인은 mappedBy 속성을 사용하지 않는다.
    > - 주인이 아닌 쪽에서 mappedBy 속성을 이용해 주인을 지정한다.
    - 주인을 지정하는 방법
    > - 데이터(테이블) 모델에서 외래키를 가지는 테이블과 매핑된 객체를 주인으로 정해라
    > - 강의 예제에서는 Member.team이 연관관계의 주인이 된다.
    > - 양방향 매핑 시 연관관계의 주인에 값을 입력해야 한다.

### ✅ 양방향 연관관계와 연관관계의 주인2 - 주의점, 정리
- 순수 객체 상태를 고려해서 항상 두 객체 모두에 값을 설정해야 한다. 
    - EntityManager에 등록된 정보가 DB에 저장되고, DB조회를 통해 새로 객체를 생성하는 경우 문제가 없다. JPA에서 연관관계 FK를 통해 양방향 탐색이 가능하도록 설정을 맞춰주기 때문에.
    - 반면, 아직 DB에 저장되지 않은 상태로 EntityManger에 남아있는 캐시에서 객체를 불러와서 양방향 탐색을 시도한다면? 연관관계의 주인인 객체(Member)에서는 소속된 팀을 세팅하고 조회할 수 있지만, 연관관계의 주인이 아닌 객체(Team)에서는 소속 선수를 조회할 수 없다. → 데이터가 꼬여서 이상하게 보이는 상황이 발생함.
    ```java
    Team team = new team();
    Member member = new member();
    ...
    // 연관관계 매핑은 Member의 FK 값을 이용해 되어 있지만 값 설정은 두 객체 모두에 해줘야 함
    member.setTeam(team);
    team.getMembers().add(member)
    ```
- 연관관계 편의 메서드를 생성하는게 좋다.
    - 위에서 살펴본 바와 같이 순수 객체 상태를 고려하면 연관관계의 주인 설정과는 별개로 항상 두 객체 모두에 값을 설정해줘야 하는데, 이걸 매번 빼먹지 않고 하기가 힘들기 때문!
    - 💡 How? Entity(Domain) layer에서 메서드를 생성해준다. 
    - 🚨 연관관계 주인을 설정하는 것과는 별개이니 헷갈리지 않도록 주의한다.
    ```java
    @Entity
    public class Member {
        
        @Id @GeneratedValue
        @Column(name = "MEMBER_ID")
        private Long id;

        ...

        @ManyToOne
        @JoinColumn(name = "TEAM_ID")
        private Team team;

        /**
        * 한쪽에서만 값을 변경해도 양쪽에 값이 설정됨
        * 반대쪽(Team)에 addMember(Member member) 메서드 추가해줘도 됨
        * 양쪽에 다 설정해두면 문제가 될 수도 있으니 상황에 따라 적절한 편의 메서드를 작성하고 반대쪽 객체는 작성하지 않는다 → 잘못하면 무한루프 걸림
        */
        public void changeTeam(Team team) {
             this.team = team; // 메서드를 호출한 객체의 팀을 설정
             team.getMembers().add(this); // team에서 불러온 멤버 리스트에 메서드를 호출한 객체를 추가
        }
    
    }
    ```
    - 기존 리스트에서 null 체크하고, 객체를 삭제하고 새로운 객체를 넣어주는 등의 복잡한 작업까지는 강의에서 안 다루고, 궁금한 경우 책을 보면 도움이 된다. 실무에서는 강의 내용 정도까지만 알아도 큰 무리없음.
- 양방향 매핑 시 무한루프를 조심하자
    - 예) toString(), lombok, JSON 생성 라이브러리
    - IntelliJ Constructor 이용해 toString() 생성하는 경우
    ```java
    @Entity 
    public class Member {
        @Override
        public String toString() {
            return "Member{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", team=" + team + // 여기서 team 넣는다는 건 이 때 team.toString()을 또 호출한다는 의미임
                    '}';
        }
    }
    ```
    - 위와 같은 코드를 작성한 뒤 Team에도 똑같이 toString()을 작성하려고 하면 Team에서도 Member의 toString()을 호출하는 메서드가 생성됨
    - 따라서 양쪽에서 서로 반대편 객체의 toString()을 무한으로 호출하게 됨 → StackOverFlow 발생함
    - 언제 자주 발생하나? Controller에서 Entity를 바로 반환하는 경우 Json 변환 과정에서 위와 같은 무한루프 생기는 경우가 대다수임
    - 어떻게 해결하나? 
        1. Lombok에서 제공하는 toString() 사용을 지양해야함.
        2. Controller에서 절대 Entity를 그냥 반환하지 말아야 함.
            - Entity를 Json으로 반환할 때 루프 문제가 생길 수 있다.
            - Entity는 언제든 변경가능한데, 엔티티를 그대로 반환하면 Entity가 변경될 때마다 API spec이 따라서 바뀌게 된다.
            - 💡 따라서 Entity는 DTO로 변환해서 반환하는걸 추천함!!!
- 🚨 양방향 매핑 정리
    - **단방향 매핑만으로도 이미 연관관계 매핑은 완료된 것이다**
    > - 즉, 단방향 매핑으로 설계는 완료되어야 함! (처음에는 양방향 매핑 하지말 것)
    > - 양방향 매핑은 반대 방향으로 조회할 수 있는 기능(객체 그래프 탐색)이 추가되는 것 뿐이다.
    > - 설계 이후 개발하다 보면 JPQL을 이용해 역방향으로 탐색할 일이 많다.
    > - 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다.
    >    - JAVA 코드만 수정하면 되고 Table 설계는 변경되지 않기 때문.

    - 연관관계의 주인을 정하는 기준
    > - 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안 됨.
    > - 연관관계의 주인은 외래 키의 위치를 기준으로 정해야 함.
    >   - 비즈니스 요구사항이 반대의 작업(예. Team에 Member를 추가)을 많이 요구한다면 앞에서 공부한 편의 메서드를 작성하는 방식으로 풀어내면 됨.

### ✅ 실전 예제 2 - 연관관계 매핑 시작
- 설계 단계에서 객체 매핑 시에 적당한 연관관계 선에서 끊어내는 것도 중요함
    > 💡 특정 회원의 주문목록을 모두 보여주고 싶다면?  
    > 이미 ORDER가 member_id 정보를 FK로 갖고 있기 때문에, 집계 연산을 하더라도 ORDER 테이블에서 수행하는 게 맞음. 굳이 MEMBER 테이블에서 양방향으로 List<ORDER> 를 바라보는 식으로 매핑해둘 필요는 없음.  
    > 💡 반대 사례로, ORDER 입장에선 ORDER_ITEM 을 역으로 조회할 수 있는게 좋음  
    > 비즈니스적으로 가치있는 연관관계임. 주문과 연관된 상품 목록을 조회하는 경우가 많기 때문에.  
- 실무에서는 복잡한 JPQL 작성을 하기 위해 양방향 연관관계를 사용하게 되는 경우가 많음

#
## [6] 다양한 연관관계 매핑
---

### ✅ 연관관계 매핑시 고려사항 3가지
- 다중성
    > - @ManyToOne, @OneToMany, @OneToOne, @ManyToMany
    > - 헷갈릴 수도 있지만 JPA가 제공하는 다양한 어노테이션은 결국 DB 와 매핑을 위해 존재하기 때문에, 데이터베이스 관점의 관계(다중성)를 기준으로 생각하면 됨. 
    > - 관계가 헷갈릴 때는 역관계를 생각해보면 됨. 예) 회원-팀이 헷가릴 땐 팀-회원 관계를 생각해보기(항상 역이 성립하기 때문)
    > - @ManyToMany는 실무에서는 사용하면 안 됨. 왜 쓰면 안되는지는 뒤에서 설명할 예쩡
- 단방향, 양방향
    > - 테이블 : FK 하나로 양방향 조인 가능, 방향의 개념이 없음
    > - 객체 : 참조 필드가 있는 쪽으로만 참조 가능, 한쪽만 참조가능하면 단방향, 양쪽이 서로 참조하면 양방향
- 연관관계의 주인
    > - 위 차이로 인해 객체에서는 연관관계의 주인이 필요해진다.

### ✅ 다대일[N:1]
- Team(1) : Member(N) 예시
- 연관관계의 주인이 되는 객체에서 테이블의 FK(TEAM_ID)에 해당하는 필드(TEAM)에 @ManyToOne을 사용해서 객체를 매핑 (@JoinColumn(name="TEAM_ID"))
- 반대편에서도 연관관계를 맺고 싶을 때는 테이블 컬럼에 변경 없이 List members 와 @OneToMany(mappedBy="team") 만 추가해주면 됨.

### ✅ 일대다[1:N]
- 권장하진 않지만 표준으로 제공되는 스펙이기 때문에 다뤄볼 예정
- 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 경우(객체는 1이 연관관계의 주인 테이블은 항상 N 쪽에 외래키가 있음)
- @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간 테이블 새로 생성).
- 다대일 관계에서 양방향 매핑을 추가해서 사용하는 편이 더 나음
    > - 객체지향 설계 관점에서 조금 손해를 보더라도 DB 설계 관점에서 유지보수가 용이해짐(trade-off 관계)
- 일대다 매핑의 단점
    > - 엔티티가 관리하는 FK가 다른 테이블에 있음
    > - 연관관계 관리를 위해 추가로 update 쿼리 실행
  
### ✅ 일대일[1:1]
- 다대일 매핑과 마찬가지로 FK 가 위치한 곳이 연관관계의 주인이 됨
- 어느 쪽에 FK를 둘지 정답은 없지만 비즈니스 로직에서 자주 사용하게 되는 쪽(많이 Access 하게 되는 테이블 = 주테이블)에 FK를 두는게 편함(영한님 생각)
    > - 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능(예. Member만 조회해도 회원이 Locker를 보유했는지 별도의 Join 없이 확인이 가능함)
    > - 단점 : 값이 없으면 외래 키에 null을 허용
- DB 모델링 관점에선 대상 테이블에 FK를 두는편을 선호할 수 있음
    > - 장점 : 주 테이블과 대상 테이블의 관계가 일대일에서 일대다로 변경될 때 테이블 구조를 유지할 수 있음
    > - 단점 : 프로시 기능의 한계로 지연로딩으로 설정해도 항상 즉시 로딩됨

### ✅ 다대다[M:N]
- 관계형 DB는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음
- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 함
- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계가 가능함
    - @ManyToMany, @JoinTable 을 통해서 매핑이 가능하긴 함.
    - 그러나, 사용해서는 안 됨...!! -> 일대다, 다대일로 풀어내자!!
- 사용하면 안 되는 이유
    - 실무에서는 연결 테이블에 여러 정보가 담기게 됨(실제 비즈니스는 생각보다 매우 복잡하다)
- 💡 다대다 한계를 극복하는 방법 : 일대다, 다대일로 풀어내기
    - 연결테이블을 @Entity로 승격
    - DB 설계 관점에서 보면 연결테이블 만들 때 양 쪽의 PK 2개를 FK를 가져와서 결합한 복합키로 PK를 설정할 수도 있지만, 경험상 PK는 GeneratedValue로 사용하는 것이 좋음. -> 나중에 유연성이 생김 :-)

### ✅ 실전 예제 3 - 다양한 연관관계 매핑
- 다대다(@ManyToMany) 실전에서는 사용하지 말자
- @ManyToOne의 주요속성인 fetch, cascade 는 뒤에서 자세히 다룰 예정임

#
## [7] 고급 매핑 
---

### ✅ 상속관계 매핑
- 관계형 DB에는 상속 관계가 없음
- 단, 슈퍼타입 서브타입 관계를 맺는 모델링 기법이 객체 상속과 유사
- 상속관계 매핑 : 객체의 상속과 DB 논리모델 상의 슈퍼타입,서브타입 관계를 매핑
- DB 슈퍼타입, 서브타입의 물리모델 모델링 전략
    1. 조인 전략 : 각각 테이블로 변환(완전한 정규화)
        - 장점
            > - 데이터가 정규화되어 있음
            > - FK 참조 무결성 제약조건 활용가능(외부 도메인에서 슈퍼타입 테이블 하나만 보면 됨)
            > - 저장공간 효율화
        - 단점
            > - 조회 시 조인을 많이 사용(성능 저하)
            > - 조회 쿼리가 복잡함
            > - 저장 시 INSERT SQL 2번 호출
    2. 단일 테이블 전략 : 통합된 하나의 테이블로 변환(하나의 테이블이 모든 서브타입 속성들을 가짐)
        - 장점
            > - 조인이 필요 없으므로 조회 성능이 빠름
            > - 조회 쿼리가 단순함(한 테이블만 보면 됨)
        - 단점
            > - 자식 엔티티가 매핑한 컬럼은 모두 Nullable로 설계해야 함 (데이터 무결성 관점에서 애매함)
            > - 테이블이 커질 수 있고 상황에 따라서 오히려 조회 성능도 저하될 수 있다(단, 이런 일은 잘 없음)
    3. 구현 클래스별 테이블화 전략 : 각각의 서브타입 테이블이 슈퍼타입 속성을 동일하게 가지게끔 변환
        - **이건 쓰면 안 되는 전략임**, DB 설계자와 ORM 전문가 둘 다 추천하지 않는 전략임
        - 장점
            > - 서브타입을 명확하게 구분해서 처리할 때 효과적, Not null 제약조건 사용 가능
        - 단점
            > - UNION SQL 사용으로 여러 자식테이블 함께 조회할 때 성능이 느림
            > - 자식테이블을 통합해서 쿼리를 수행하기 어려움(매출 정산 이런거 어려움...)
- **JPA의 기본 매핑 전략(단순히 @Entity만 사용하는 경우)은 단일 테이블 전략임**
- 주요 어노테이션
    - @Inheritance(stratege=InheritanceType.XXX)
        > - JOINED : 조인 전략
        > - SINGLE_TABLE : 단일 테이블 전략
        > - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
    - @DiscriminatorColumn(name="DTYPE")
    - @DiscriminatorValue("XXX")
- 데이터 모델이 변경 되어도 코드 수정 없이 어노테이션만 바꿔서 반영이 가능하다 ➡️ JPA의 큰 장점
- 기본적으로 조인 전략을 염두에 두고, 단일 테이블 전략과의 트레이드 오프를 고려하여 선택하면 됨
    - 💡 영한님 Tip 💡 
    > 단순하고, 확장 가능성도 적은 경우에 단일테이블 사용. 비즈니스적으로 중요하고 복잡한 경우 조인전략을 사용

### ✅ Mapped Superclass - 매핑 정보 상속
- 작성자, 작성시간, 최종수정자, 최중수정시간 등의 속성을 모든 테이블에서 같이 사용하고 싶을 때 쓸 수 있는 어노테이션
```java
    
    @Getter @Setter
    @MappedSuperclass
    public abstract class BaseEntity { // 공통 속성을 관리하는 클래스
        
        private String createdBy;
        private LocalDateTime createdDate;
        private String lastModifiedBy;
        private LocalDateTime lastModifiedDate;

    }

    @Entity
    public class Member extends BaseEntity { // 이를사용하는 엔티티

        @Id @GeneratedValue
        @Column(name = "MEMBER_ID")
        private Long id;

        ...

    }
```
- 상속관계 매핑이 아님
- 엔티티가 아니기 때문에 테이블과 매핑되지 않음(테이블과 관계 없고 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할)
- 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공
- 조회, 검색 불가(em.find(BaseEntity.class) 불가함)
- 직접 생성해서 사용할 일 없으므로 추상 클래스 권장함 (💡실무에서 유용하게 쓰기 좋음)
- 참고 : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능함

### ✅ 실전 예제 4 - 상속관계 매핑

#
## [8] 프록시와 연관관계 정리
---

